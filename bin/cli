#!/usr/bin/env node

// require('shelljs/global');
// var argv = require('yargs').argv;
// const exec = require('child_process').exec;
const pm2 = require('pm2');
const child_process = require('child_process');
// const fis = require('fis3');
// var shell = require("shelljs");
const program = require('commander')
const prompt = require('co-prompt')
const co = require('co')
const chalk = require('chalk')
const chokidar = require('chokidar');
const webpack = require("webpack");
const download = require("download-git-repo");
const fs = require('fs');
const rm = require('rimraf');
// var argv = require('minimist')(process.argv.slice(2));
// var path = require('path');

//检测文件或者文件夹存在 nodeJS
function fsExistsSync(path) {
    try{
        fs.accessSync(path,fs.F_OK);
    }catch(e){
        return false;
    }
    return true;
}
program
    .version('1.0.0')

program
    .command('init <option>')
    .description('Generate a new app')
    .action((option) => {
        co(function*() {
            if (option == 'app') {
                let appName = yield prompt('App name: ');
                let fileMap = [
                    `${appName}/config.js`,
                    `${appName}/package.json`,
                    `${appName}/server/action/api/Api.js`,
                    `${appName}/server/action/show/Home.js`,
                    `${appName}/server/controller/Main.js`
                ];

                console.log(chalk.white('\n Start generating...'));
                download('bunjs/bun-app', './' + appName, function (err) {
                    if (err) {
                        console.log(err)
                        process.exit()
                    }
                    console.log(chalk.white('\n download file completed!'));
                    rm(appName + '/.git', err => {
                        if (err) {
                            throw err;
                        }
                        console.log(chalk.white('\n remove file completed!'));
                        try {
                            for (let i = 0; i < fileMap.length; i++) {
                                if (fsExistsSync(fileMap[i])) {
                                    let text = fs.readFileSync(fileMap[i], 'utf-8');
                                    text = text.replace(/\$_appname/g, appName);
                                    fs.writeFileSync(fileMap[i], text);
                                }
                            }
                            console.log(chalk.white('\n replace file completed!'));
                            console.log(chalk.green('\n √ Generation completed!'))
                            console.log(`\n cd ${appName} && npm install \n`)
                            process.exit()
                        } catch (e) {
                            console.log(e)
                            process.exit()
                        }
                    });
                })
                
            } else if (option == 'project') {
                let projectName = yield prompt('Project name: ');
                let fileMap = [
                    `${projectName}/ecosystem.config.js`,
                    `${projectName}/package.json`
                ];
                console.log(chalk.white('\n Start generating...'))
                download('bunjs/bun-project', './' + projectName, function (err) {
                    if (err) {
                        console.log(err)
                        process.exit()
                    }
                    rm(projectName + '/.git', err => {
                        if (err) {
                            throw err;
                        }
                        console.log(chalk.white('\n remove file completed!'));
                        try {
                            for (let i = 0; i < fileMap.length; i++) {
                                if (fsExistsSync(fileMap[i])) {
                                    let text = fs.readFileSync(fileMap[i], 'utf-8');
                                    text = text.replace(/\$_projectname/g, projectName);
                                    fs.writeFileSync(fileMap[i], text);
                                }
                            }
                            console.log(chalk.white('\n replace file completed!'));
                            console.log(chalk.green('\n √ Generation completed!'))
                            console.log(`\n cd ${projectName} && npm install \n`)
                            process.exit()
                        } catch (e) {
                            console.log(e)
                            process.exit()
                        }
                    });
                })
            } else if (option == 'ssrapp') {
                let appName = yield prompt('App name: ')
                let fileMap = [
                    `${appName}/config.js`,
                    `${appName}/package.json`,
                    `${appName}/src/app/example/page/home/home.jsx`,
                    `${appName}/src/app/example/page/pageone/pageone.jsx`,
                    `${appName}/src/app/example/index.js`,
                    `${appName}/server/action/show/Example.js`,
                    `${appName}/server/action/api/Api.js`,
                    `${appName}/server/controller/Main.js`,
                    `${appName}/server/model/services/DataStation.js`,
                    `${appName}/server/model/services/page/ExampleHomeShow.js`,
                    `${appName}/server/model/services/page/ExampleOneShow.js`
                ];

                console.log(chalk.white('\n Start generating...'))
                download('bunjs/bun-ssrapp', './' + appName, function (err) {
                    if (err) {
                        console.log(err)
                        process.exit()
                    }
                    rm(appName + '/.git', err => {
                        if (err) {
                            throw err;
                        }
                        console.log(chalk.white('\n remove file completed!'));
                        try {
                            for (let i = 0; i < fileMap.length; i++) {
                                if (fsExistsSync(fileMap[i])) {
                                    let text = fs.readFileSync(fileMap[i], 'utf-8');
                                    text = text.replace(/\$_appname/g, appName);
                                    fs.writeFileSync(fileMap[i], text);
                                }
                            }
                            console.log(chalk.white('\n replace file completed!'));
                            console.log(chalk.green('\n √ Generation completed!'))
                            console.log(`\n cd ${appName} && npm install \n`)
                            process.exit()
                        } catch (e) {
                            console.log(e)
                            process.exit()
                        }
                    });
                })
            }

        })
    })

program
    .command('run <app>')
    .description('start the bun')
    .action((app) => {
        co(function*() {
            console.log(chalk.white('\n Starting bunko...'))
            pm2.connect(function(err) {
                if (err) {
                    console.error(err);
                    process.exit(2);
                }

                pm2.start({
                    name: app,
                    script: process.cwd() + '/entry.js', // Script to be run
                    watch: true,
                    ignore_watch: [process.cwd() + "/logs",process.cwd() + "/node_modules"],
                    error: process.cwd() + '/logs/bun/bun.log.wf',
                    output: process.cwd() + '/logs/bun/bun.log',
                    max_memory_restart: '1000M' // Optional: Restarts your app if it reaches 100Mo
                }, function(err, apps) {
                    pm2.disconnect(); // Disconnects from PM2
                    if (err) {
                        throw err;
                        process.exit()
                    }
                    console.log(chalk.green('\n √ Starting completed!'))
                    process.exit()
                    
                });
            });
        })
    })
program
    .command('stop <app>')
    .description('stop the bun')
    .action((app) => {
        co(function*() {

            pm2.connect(function(err) {
                if (err) {
                    console.error(err);
                    process.exit(2);
                }

                pm2.stop(app, function(err, apps) {
                    pm2.disconnect(); // Disconnects from PM2
                    if (err) {
                        throw err;
                        process.exit()
                    }
                    console.log(chalk.green('\n √ Stoping completed!'))
                    process.exit()
                    
                });
            });
        })
    })
program
    .command('release')
    .description('deploy the app')
    .alias('r')
    .option("-d, --dev", "if development")
    .option("-t, --to [path]", "Which project to deploy")
    .option("-w, --watch", "if watching the app")
    // .option("-dev, --dev", "if development")
    .action((options) => {
        co(function*() {
            let path = options.to
            let dev = options.dev
            let webpackConfig;
            if (dev) {
                userConf = require(process.cwd() + '/config.js')
                webpackConfig = require('./webpack.config-dev.js')(userConf)
                // webpackConfig = require(process.cwd() + '/webpack.config-dev.js')
            } else {
                userConf = require(process.cwd() + '/config.js')
                webpackConfig = require('./webpack.config.js')(userConf)
                // webpackConfig = require(process.cwd() + '/webpack.config.js')
            }
            
            console.log(chalk.white('\n Start deploying...'))
            webpack(webpackConfig, (err, stats) => {

                if (err || stats.hasErrors()) {
                    // 在这里处理错误
                    console.log(stats)
                    process.exit()
                }
                let files = fs.readdirSync('./build/server/');
                let appName = files[0];
                let fileMap = {
                    './build/server/': `${path}/app/`,
                    './build/conf/': `${path}/conf/`,
                    './build/static/': `${path}/static/`,
                    './build/template/': `${path}/template/`,
                    './build/src/': `${path}/src/`
                }
                function _copy(src, dist) {

                    let paths = fs.readdirSync(src);
                     
                    paths.forEach(function(path) {
                        var _src = src + '/' +path;
                        var _dist = dist + '/' +path;
                        let stat = fs.lstatSync(_src);
                        if (stat.isDirectory()) {
                            // 当是目录是，递归复制
                            copyDir(_src, _dist)
                        } else {
                            fs.writeFileSync(_dist, fs.readFileSync(_src));
                        }
                    })
                }
                
                function copyDir(src, dist) {
                    if (!fsExistsSync(dist)) {
                        fs.mkdirSync(dist);
                    }
                    _copy(src, dist);
                }
                try {
                    for (let i in fileMap) {
                        if (fsExistsSync(i + appName)) {
                            if (!fsExistsSync(fileMap[i])) {
                                fs.mkdirSync(fileMap[i]);
                                copyDir(i + appName, fileMap[i] + appName);
                                // child_process.spawn('cp', ['-r', i + appName, fileMap[i]]);
                                // fs.renameSync(i + appName, fileMap[i] + appName);
                            } else {
                                copyDir(i + appName, fileMap[i] + appName);
                                // child_process.spawn('cp', ['-r', i + appName, fileMap[i]]);
                                // fs.renameSync(i + appName, fileMap[i] + appName);
                            }
                        }
                    }
                    rm('./build', err => {
                        if (err) {
                            throw err;
                        }
                        console.log(chalk.white('\n remove build completed!'));
                        console.log(chalk.green('\n √ Deploy completed!'))
                        if (options.watch) {
                            // 使用chokidar监控app文件变化，自动部署，仅限线下调试使用
                            const watcher = chokidar.watch([process.cwd() + '/server', process.cwd() + '/src', process.cwd() + '/conf', process.cwd() + '/webpack.config.js']);
                            // watcher.on('ready', () => {
                                
                                watcher.on('change', (path, stats) => {
                                    if (stats) console.log(chalk.green(`File ${path} changed size to ${stats.size}`));
                                    webpack(webpackConfig, (err, stats) => {
                                        if (err || stats.hasErrors()) {
                                            // 在这里处理错误
                                            console.log(err)
                                            process.exit()
                                        }
                                        for (let i in fileMap) {
                                            if (fsExistsSync(i + appName)) {
                                                if (!fsExistsSync(fileMap[i])) {
                                                    fs.mkdirSync(fileMap[i]);
                                                    fs.renameSync(i + appName, fileMap[i] + appName);
                                                }
                                            }
                                        }
                                        
                                    });
                                    
                                });
                            // });
                        } else {
                            process.exit()
                        }
                    });
                    
                } catch (e) {
                    console.log(e)
                    process.exit()
                }
                
            });
        })
    })

program.parse(process.argv);